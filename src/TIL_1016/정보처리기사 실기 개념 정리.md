# 정보처리기사 실기 개념모음

---

UML(Unified Modeling Language)의 관계

---

- 복합연관/합성 관계(Composition)
  - 색칠된 마름모
- 집합 관계(Aggregation)
  - 빈 마름모
- 일반화 관계(Generalization)
  - 실선 빈 화살표
- 현실화 관계(Realization)
  - 점선 빈 화살표
- 의존 관계(Dependency) 
  - 점선 색칠된 화살표
- 연관 관계(Association) 
  - 실선 혹은 화살표



- 하향식(Top-down) 통합 테스트
  - 스텁(Stub)
    - 하위층의 더미 모듈 및 컴포넌트
  - 깊이-우선 or 너비-우선 방식



---

버퍼 오버플로우(Buffer Overflow)

----

- 스택가드(Stack Guard)
  - 카나리(canary)라는 무결성 체크용 값을 복귀주소와 변수 사이에 삽입
- 스택쉴드(Stack Shield)
  - 복귀 주소로 Global RET라는 특수스택에 저장, 값이 다를 경우 실행 중단 
- 주소 공간 난수화(ASLR, Adress Space Layout Randomization)
  - 실행 시마다 메모리 주소 변경



---

프로세스 스케줄링 알고리즘

---

- SRT(Shortest Remaining Time First)
  - 가장 짧은 시간이 소요되는 프로세스 먼저 수행
  - 남은 처리시간이 더 짧은 프로세스가 준비 큐에 생기면 언제든지 프로세스가 점유__(선점)__됨

- SJF(Shortest Job First)
  - 프로세스가 도착하는 시점에서 가장 작은 서비스 시간의 프로세스가 종료할 때까지 자원 점유



- 에이징(Aging)

  - 자원 대기 시간에 비례하여 우선순위 부여

  - 무기한 대기 문제를 방지

  

- 쓰레싱(Thrashing) 현상
  - 하나의 프로세스가 기억장치 지나치게 접근
  - 페이지 폴트(Page Fault) 발생
  - 페이지 이동 소요시간 > 프로세스 수행 소요시간 

- 해결 방안
  - 워킹셋(Working Set)
    - 일정 시간 자주 참조하는 페이지 집합
    - 메모리 공간에 상주
    - 빈번한 페이지 교체 현상 감소화
  - PFF (Page Fault Frequency)
    - 페이지 부재율의 상한과 하한 설정
    - 페이지 부재율 예측 및 조절



- 교착상태(Deadlock)

  - 둘 이상의 프로세스가 서로 한정된 자원 요청

  - 모든 프로세스가 대기 상태로 전환

- 발생 원인

  - 상호 배제
  - 점유와 대기
  - 비선점
  - 환형 대기

- 해결 방안

  - 예방(Prevention)
    - 점유 자원 해제 후 새 요청
  - 회피(Avoidance)
    - 은행가 알고리즘(Banker's Algorithm)
    - Wait-die
    - wound-wait
  - 발견(Detection)
    - 자원할당 그래프
    - Wait for Graph
  - 회복(Recovery)
    - 프로세스 킬(Kill)



---

DRM(Digital Right Management) 구성요소

---

- 콘텐츠 제공자(Contents Provider)
  - 콘텐츠를 제공하는 저작권자
- 패키저(Packager)
  - 콘텐츠를 메타 데이터와 함께 배포 가능한 단위로 묶는 기능
- DRM 컨트롤러(DRM Controller)
  - 배포된 콘텐츠의 이용 권한을 통제



- SSO(Single Sign On) 인증 시스템
  - 한 번의 인증을 통해
  - 여러 개의 서비스를 이용할 수 있는 시스템



- 디지털 트윈(Digital Twin)

  - 물리적인 사물과 컴퓨터에 동일하게 표현되는 가상모델

  - 실제 자산 대신 소프트웨어로 가상화
  - 실제 자산의 특성에 대해 정확한 정보 얻음
  - 자산 최적화/돌발사고 최소화/생산성 증가 등 설계, 제조, 서비스 모든 과정의 효율성 향상

  

- 가상 물리 시스템(CPS, Cyber Physical System)
  - 대규모 센서/액츄에이터를 갖는 물리적 요소들, 통신기술, 응용/시스템 SW기술 활용
  - 실시간으로 물리적 요소들을 제어하는 컴퓨팅요소가 결합된 복합 시스템



- 이상현상(Anormaly)
  - 릴레이션 조작 시
  - 데이터들이 불필요하게 중복 / 데이터의 중복성
  - 예기치 않게 발생하는 곤란한 현상 / 비합리적 현상



- JDBC(Java DataBase Connectivity)
  - 자바(Java)에서
  - 데이터베이스를 사용할 수 있도록
  - 연동/연결해주는 응용 프로그램 인터페이스



- 형상관리
  - 개발중인 SW의 / SW 개발의 전체 과정
  - 모든 항목의 수정/변경 사항을 관리하는 활동



- API 기법
  - 애플리케이션 레벨에서 암호 모듈을 적용
  - 애플리케이션 수정 방식의 DB 암호화 기법



- 비트 락커(BitLocker)

  - MS Windows 운영체제에 포함
  - 볼륨 전체의 암호화를 제공
  - 자료를 보호하도록 설계된 완전한 디스크 암호화 기능

  

- 빅데이터(Big Data)

  - 수 십 페타 Byte 이상
  - 주어진 비용과 시간 내에 처리가능한 데이터 범위를 넘어서는 정형/비정형/반정형 데이터

  

- 인공지능(AI)
  - 인간의 지적능력을 구현
  - 인간의 지능적 행동과 사고를 모방하는 SW 프로그램



- Ajax(Asynchronous JavaScript And XML)

  - 자바스크립트를 이용
  - 웹 서버와 클라이언트 간 비동기적 통신
  - XML 데이터를 교환하고 조작하는 웹 기술

  - 새로고침 없이 웹 페이지의 일부 화면만 로딩/수정할 수 있음.



---

보안 공격 기법

---

- 스머프(Smurf) 공격기법
  - 출발지 주소를 공격 대상의 IP 주소로 설정
  - ICMP Echo 패킷을 직접 브로드캐스팅
  - 모든 서브 네트워크를 마비시키는 공격기법

- 랜드 어택(Rand Attack)

  - 패킷 출발지 주소/포트를 변경
  - 출발지와 목적지 주소를 동일하게 지정
  - 공격 대상 컴퓨터의 실행속도 느리게 or 동작 마비 => 서비스 거부 상태


- 제로 데이(Zero Day) 공격
  - 취약점에 대한 패치가 나오지 않은 시점



- 방화벽(Firewall)
  - 네트워크 보안 시스템
  - 미리 정의된 보안 규칙에 기반
  - 네트워크 트래픽을 모니터링 & 제어
  - 외부의 불법 침입 + 내부의 불법 유출 방지
  - 내/외부 네트워크 상호간 영향 차단 보안 장비



- SAN(Storage Area Network)
  - 광케이블 / 광 채널 스위치를 통해
  - 서버와 스토리지 위에 근거리 네트워크 환경을 구성
  - 특수 목적용 고속(빠른 속도로 데이터를 처리하는) 네트워크



- IPSEC
  - IP 계층의 보안 프로토콜
  - 무결성과 인증을 보장하는 인증헤더(AH, Authentication Header)
  - 기밀성을 보장하는 암호화(ESP, Encapsulating Security Payload)
  - 양 종단(End Point) 구간에 보안 서비스를 제공



---

트랜잭션(Transaction)

---

- 트랜잭션의 특징
  - 원자성(Atomicity)
  - 일관성(Consistency)
  - 격리성(Isolation)
    - 트랜잭션이 실행되는 동안
    - 생성하는 연산의 중간 결과를
    - 다른 트랜잭션이 접근하지 못하도록 보장
  - 영속성(Durability)

- 커밋(Commit)
  - 트랜잭션이 성공적으로 끝난 후
  - DB 일관성이 있는 상태일 때 사용

- 롤백(Roll-back)
  - 트랜잭션 처리 중 오류가 발생
  - 오류 이전의 특정 시점(savepoint, checkpoint) 상태로 되돌려주는 제어어(명령어)



---

병행제어 기법

---

- 로킹(Locking)
  - 트랜잭션이 사용하는 데이터 항목 잠금(Lock)
  - 독점적으로 사용할 수 있게 상호배제 기능 제공
  - 로킹 단위
    - 로킹 대상 객체의 크기
    - 小 : 병행 수준 뛰어남, 관리 어려움
    - 大 : 병행수준 낮음, 관리 쉬움



---

UI 시나리오 문서 작성의 요건

---

- 완전성(Complete)
  - UI 시나리오는 누락이 없어야 함 & 최대한 빠짐 없이 가능한 상세하게 기술
  - 기능보다 사용자의 Task에 초점
- 일관성(Consistent)
  - 서비스 목표, 시스템/사용자 요구사항이 일관성
  - 모든 UI 스타일(Flow 또는 Layout)이 일관적
- 이해성(Understandable)
  - 처음 접하는 사람도 이해하기 쉽도록 구성 및 설명
  - 추상적 표현, 어려운 용어 지양
- 가독성(Readable)
  - 쉽게 읽을 수 있는 표준화된 템플릿
  - 버전 넘버링 일관성
  - 하이라이팅 일관성
- 추적 용이성(Traceable)
  - 변경, 수정 또는 개선이 쉽게 반영
- 수정 용이성(Modifiable)
  - 변경사항 추적 쉬워야함 (언제, 어디서, 왜)



- DRM(Digital Right Management)
  - 디지털 콘텐츠에 대한 권리정보를 지정
  - 암호화 기술, 크랙방지 기술 이용
  - 허가된 사용자 & 허가된 권한 범위 & 의도한 용도
  - 콘텐츠 이용이 가능하도록 통제하는 기술 / 활동



----

결합도(Coupling)

---

- 자료(Data) 결합도
  - 단순 자료로만 매개변수로 전달 & 참조
- 스탬프(Stamp) 결합도
  - 모듈 간 인터페이스로 배열/객체/구조 전달
- 제어(Control) 결합도
  - 다른 모듈 내부의 논리적 흐름을 제어하기 위해
  - 처리해야 하는 제어 요소(flag 등)까지 전달
- 외부
  - 외부 환경(H/W, 프로토콜, OS, 컴파일러 등)과 연관
- 공통
  - 글로벌 데이터(전역변수)를 공유
- 내용(content) 결합도
  - 다른 모듈의 변수, 기능 직접 참조/사용



---

응집도(Cohesion)

---

> 모듈의 독립성, 내부 구성요소 간 연관 정도
> 정보은닉의 확장 개념
> 하나의 모듈은 하나의 기능을 수행

- 기능적 응집도
  - 모듈 내 모든 요소가 단일 기능 수행
- 순차적
  - 모듈 내 한 요소의 출력이 다른 요소의 입력
- 교환적
  - 모듈 내 요소들이 동일한 입출력 자료로 다른 기능 수행
- 절차적
  - 모듈 수행 요소들이 반드시 정해진 순서대로 수행
- 시작적/일시적
  - 특정 시간에 실행되는 기능들을 모은 모듈
- 논리적
  - 논리적으로는 유사하나 기능적 관계는 X
- 우연적
  - 전혀 뚜렷한 관계가 없는 요소들간의 모듈



- 웹 접근성(Web Accessiblity)

  > KWCAG(Korean Web Content Accessibility Guideline) 2.0
>
  > 장애인과 비장애인이 동등하게 웹사이트 콘텐츠에 접근 보장
  
  - 인식의 용이성(Perceivable)
    - 대체 텍스트(Text Alternatives), 미디어 대체 수단, 융통성, 식별성
  - 운용의 용이성(Operable)
    - 조작, 내비게이션, 키보드 접근성, 충분한 시간, 발작 예방, 탐색 가능성
  - 이해성(Understandable)
    - 가독성, 예측 가능성, 입력 자원
  - 견고성(Robust)
    - 미래의 사용자/다른 프로그램 간의 호환성 극대화

- 웹접근성 진단 도구
  - OpenWAX
  - 웹 브라우저 개발자도구



- IPv4
  - 인터넷 패킷 교환 네트워크 상 데이터 교환
  - 32bit 주소체계
  - 네트워크 계층의 프로토콜
  - 헤더 크기는 가변적
  - 전송방식 : 유니캐스트(1:1), 멀티캐스트(M:N), 브로드캐스트(1:N)



- IPv6

  - 128bit 주소체계
  - 헤더 크기 고정적

  - 전송방식 : 유니캐스트, 멀티캐스트, 애니캐스트



- 요구사항 분석 기법

  > 개념 모델링

  - 문제 도메인의 엔티티(Entity)들과 개별 관계, 종속성을 반영
  - 시나리오로 나타내기 위해 유스케이스 다이어그램 사용
  - 모델링 표기법은 UML 사용



- UI 품질 요구사항

  - 사용성(Usability)

    > 사용자와 컴퓨터 간 행위를 정확하고 쉽게 인지 가능

    - 이해성(Understandability) - SW의 논리적 개념, 적용 가능성을 분간하는데 필요한 사용자의 노력
    - 학습성(Learnability) - SW 애플리케이션을 익히는 데 필요한 사용자의 노력
    - 운용성(Operability) - SW 활용과 운용 통제에 필요한 사용자의 노력



---

클린 코드 작성 원칙

---

- 가독성

  - 이해하기 쉬운 용어, 들여쓰기 기능

- 단순성

  - 한 번에 한 가지 처리
  - 최소 단위로 분리

- 의존성

  - 코드 변경 시 영향도 최소화

- 중복성

  - 공통된 코드 사용

- 추상화

  

- 소스 코드 최적화 기법
  - 클래스 이름은 명사(구) - 주체
  - 함수 이름은 동사(구) - 행위
  - 클래스의 높은 응집도
  - 클래스 간의 의존성 최소화
  
  

---

연계 요구사항 분석기법

---

- 체크리스트
  - 시스템 운영 환경, 성능, 보안, 데이터 발생 주기 등
  - 기준에 대한 점검을 통해 분석
- 브레인스토밍
  - 소속된 인원들이 자발적으로 자연스럽게
  - 제시된 아이디어 목록을 통해 분석
- 정형 분석(Formal Analysis) & 정형 명세(Formal Specifiaction)
  - 구문(Syntax)과 의미(Sematic)를 갖는 언어 이용
  - 요구사항 수학적 기호로 표현
- 델파이 조사기법
  - 시스템 아키텍처/연계/업무 분야별 전문가로 구성

- 인터뷰
- 설문지/설문조사
- 연계 솔루션 비교



- 저장된 프로시저(Stored Procedure)
  - 배치 작업, 복잡한 트랜잭션을 수행하는 PL / SQL문
  - DB에 저장하는 기능



- 프로시저 LOOP문
  - EXIT WHEN 탈출조건:



- 트리거(Trigger)
  - 테이블에 CRUD 변경 이벤트 발생 시
  - DBMS에서 자동 실행 구현 프로그램



- 배포 프로세스
  - 빌드 내용 식별
  - 패키징 도구 식별
  - DRM 흐름 파악 & 패키지 수행
  - 패키징 도구 설치
  - 배포 작업
  - 정상 배포 확인



- 빌드 도구
  - Gradle
  - Maven
  - Ant

- 패키징 도구

  > 크랙 방지를 제공하는 패키징 도구 구성요소

  - (소스) 코드 난독화(Code Obfuscation)

    - 역공학 방지

    - 프로그램 소스 코드 알아보기 힘들게



- ODBC(Open DataBase Connectivity)
  - 데이터베이스를 액세스
  - 표준 개방형 응용 프로그램 인터페이스



- 소스 코드 최적화 기법
  - 인터페이스를 통해
  - 추상화된 자료구조 구현 => 의존성 최소화



- System.out.println() 사용 제외
  - 파일, 콘솔에 로그를 남기면 애플리케이션 대기시간 발생
  - Log4j 로거 사용 => 성능 개선



- tpmC(Transaction Processing perforMance Council)
  - 특정 서버에 자체 기준으로 테스트 수행
  - 1분간 최대 처리건수 수치
  - 객관적인 하드웨어(HW) 성능 지표



- RUDY(Slow HTTP POST DoS)
  - 요청 헤더의 Content-length를 비정상적으로 크게 설정
  - 메시지 바디 부분을 매우 소량으로 전송
  - 연결상태 유지, 자원 소진



- 티어드롭(Tear Drop)
  - IP Fragment Offset 값을 서로 중첩되도록 조작
  - 수신한 시스템이 재조합하는 과정에서 오류 발생
  - 시스템 기능 마비



- 자료구조(Data Structure)
  - 데이터를 삽입, 삭제, 수정하게 해주는 논리적인 공간 구조
  - 단순 구조, 선형 구조, 비선형 구조, 파일 구조로 분류



- OSI(Open System Interconnection) 7계층 中 네트워크 계층
  - 여러 개의 노드를 거칠 때마다 경로를 찾아주는 역할
  - 데이터 전송 단위
    - 패킷(Packet) : 데이터를 일정 크기로 자른 것
  - 라우팅, 패킷, 포워딩 수행
  - IP, ARP, BGP, RARP 등의 프로토콜 사용



- 인스펙션(Inspection)
  - SW 요구, 설계, 원시 코드 등
  - 시스템의 저작자 외 각 분야에 대한 전문가들이 검사

  - 공식적인 검토 활동

  - 정적 테스트 기법

  

- 사용성 테스트(Usability Test)

  - UI 개발 주요 기법
  - 사용자가 직접 제품을 사용
  - 작성된 시나리오에 맞춰 과제 수행 후 답변



- 테스트 시나리오(Test Scenario)
  - 테스트 케이스의 집합
  - 동작 순서를 기술한 문서
  - 테스트 절차를 명세한 문서



- 애플리케이션 테스트
  - 회복(Recovery) 테스트
    - 요구사항에 따라 고의로 실패를 유도
    - 정상적 복귀 여부를 확인
  - 조건/결정 커버리지(Condition/Decision Coverage)
    - 개별 조건식도 참 & 거짓 한 번씩 결과가 되도록 수행



- TDD(Test Driven Development)
  - 테스트 코드를 먼저 작성하고 서비스 코드 작성



---

스케줄링(Scheduling) 방식

---

- 다단계 피드백 큐(Multi Level Feedback Queue)
  - FCFS(=FIFO)와 라운드 로빈 스케줄링(RR) 기법을 혼합
  - 새로운 프로세스는 높은 우선순위
  - 실행시간이 길어질수록 낮은 우선순위 큐로 이동
  - 마지막 단계는 라운드 로빈 방식 적용

- SJF(Shortest Job First)
  - 도착 시점에서 가장 작은 서비스 시간을 갖는 프로세스
  - 종료 시까지 자원을 점유
  - 준비 큐 작업 중 가장 짧은 작업부터 수행
  - 평균 대기시간이 최소가 되는 프로세스 스케줄링

- HRN(Highest Response Ratio Next)
  - (대기시간 + 서비스 시간) / 서비스 시간



- 인터페이스 구현 검증 도구

  - FitNesse

    - 웹 기반 테스트 케이스 설계/실행/결과확인 지원하는 프레임워크
    - TC 테이블 작성 시 빠르고 편하게 자동으로 테스트

    

  - watir(Web Application Test in Ruby)

    - 루비(Ruby) 기반 웹 애플리케이션 테스트 프레임워크
    - 모든 언어 기반의 WAT와 브라우저 호환성 테스팅 가능



- 강도 테스트(Stress Test)
  - 시스템에 과도 정보량 부과
  - 과부하 시 정상 작동 검증



- 회귀 테스트(Regression Test)
  - 오류를 제거/수정한 시스템
  - 새롭게 유입된 오류 여부 확인
  - 일종의 반복 테스트 기법



- 스토리보드(Story Board)
  - UI 화면 설계
  - 구축 서비스의 대부분 정보(정책, 프로세스, 콘텐츠 구성, 와이어프레임, 기능 정의, DB연동) 수록
  - 디자이너와 개발자가 최종적으로 참고하는 산출 문서



- 크라임웨어(Crimeware)
  - 온라인 상에서 불법 활동을 조장
  - 공격용 툴킷
  - 보안 취약점을 이용
  - 미리 프로그램된 악성코드 등 공격 자동화
  - 키로거를 은밀히 설치하여 불법적 정보 수집



---

BCP(Business Continuity Planning)

---

> 기업이 재해/재난으로부터 업무를 어떻게 복구하는지 계획
>
> 단순 복구 + 비즈니스 지속성 보장 (넓은 개념)

- 재해 복구시간 목표(RTO, Recovery Time Objective)

  - 재해로 인한 서비스 중단을 복구하는데 거리는 최대 허용 시간

- 재해 복구시점 목표(RPO, Recovery Point Objective)

  - 재해로 인한 서비스 중단 시 유실을 감내할 수 있는 데이터 손실 허용 시점

  

---

보안의 3요소

---

- 기밀성(Confidentiality)
  - 인가된 사용자만 접근 허용
  - 전송중 노출 시 시스템 내의 정보와 자원 못 읽게 차단
- 무결성(Integrity)
  - 인가된 사용자만 수정/변경 가능
  - 시스템 내의 정보와 자원 변조/훼손/파손 차단 
- 가용성(Availability)
  - 서비스가 계속 유지
  - 시스템이 장애 없이 정상적으로 운영되는 능력



---

결함 우선순위

---

- 결정적(Critical)
  - 24시간 내에 즉시 수정
  - 전체 기능 동작 X, 테스트 진행 X
- 높음(High)
  - 다른 기능 사용할 수 없음
- 중간(Mediate)
  - 
- 낮음(Low)
  - 



---

결함 조치 상태

---

- 열린(Open)
  - 오류가 보고되었지만 아직 분석 되지 않음
- 할당된(Assigned)
  - 수정을 위해 오류가 개발자에게 보고된 상태
- 연기된(Deferred)
  - 낮은 우선순위
  - 오류 수정 연기한 상태
- 종료된(Closed)
  - 재테스트 시 오류가 발견되지 않음
- 수정된(Fixed)
  - 개발자가 오류를 수정한 상태
- 분류된(Classified)
  - 보고된 오류를 확인했을 때
  - 오류가 아니라고 확인된 상태



- APT(Advanced Persistent Threat)
  - 특수 목적을 가진 조직
  - 하나의 표적에 다양한 IT 기술 이용
  - **지속적으로** 정보 수집 및 취약점 파악
  - 지능적인 맞춤형 공격
  - 침투, 검색, 수집, 유출하는 공격기법



- 킬 스위치(Kill Switch)
  - 잃어버린 스마트폰으로 와이파이/이동통신망 접속 시
  - 원격으로 기기 사용 불능 상태
  - 멀웨어테크 영국 보안전문가가 도메인 정식 등록
  - 워너크라이 랜섬웨어 확산이 멈춘 효과



- 랜섬웨어(Ransomware)
  - 사진, 문서 암호화 악성 프로그램
  - 복호화의 대가로 금전 요구



- 다크 데이터(Dark Data)
  - 정보를 수집한 후 저장만 하고 분석에 사용하지 않는 다량의 데이터
  - 미래 사용 가능성의 이유로 방치
  - 저장공간 낭비 & 보안 위험 초래



- 스턱스넷(Stuxnet)
  - 웜 바이러스의 일종
  - 지멘스의 SCADA 시스템만을 감염
  - 장비를 제어하고 감시하는 특수한 코드 (이란 폐쇄망 핵시설 겨냥)
  - PC에 USB 꽂으면서 핵시설 시스템 공격
  - 장비를 프로그램하는 PLC 감염 후 장비 동작 변경



- 브로드캐스트(Broadcast)
  - 하나의 송신자
  - 같은 서브 네트워크 상의 모든 수신자
  - 데이터 전송 기술



---

암호화 알고리즘

---

> 단방향 vs 양방향 알고리즘
>
> 대칭 키 vs 비대칭 키 방식

- 양방향 비대칭 키 암호화 
  - PKI(Public Key Infrastructure)
    - 공개키 암호 방식 기반 / 공개키 알고리즘을 통한 암호화 및 전자서명 제공
    - 디지털 인증서 활용 SW, HW, 유저, 정책 등 총칭
    - 암호화 & 복호화 키로 구성된 공개키
    - 송수신 데이터 암호화 + 디지털 인증서
    - 패키징 도구 암호화 기술
- 양방향 대칭 키 암호화
  - ARIA(Academy, Research, Institute, Agency)
    - 국내
    - 국가정보원에서 개발
    - 128bit
  - AES(Advanced Encryption Standard)
    - 미국 표준 기술 연구소(NIS)에서 개발
    - AES128, AES192, AES256
  - DES(Data Encryption Standard)
    - 64bit 암호화 단위
    - DES, Triple(3) DES

- 게이트웨이(Gateway)

  - 프로토콜을 서로 다른 통신망에 접속할 수 있게 하는 장치
  - LAN에서 네트워크간의 데이터 출입구 역할

  

---

라우팅 프로토콜

---

- RIP(Routing Information Protocol)

  - 최초의 라우팅 프로토콜

  - 거리 벡터 알고리즘
  - 30초 주기로 전체 라우팅 정보 갱신
  - 변화 업데이트 시 많은 시간 소요

  - 라우팅 루프 발생 가능

- IGRP(Interior Gateway Routing Protocol)
  - RIP 업그레이드
- OSFP(Open Shortest Path First)
  - 링크 상태 알고리즘
- BGP(Broad Gateway Protocol)
  - 규모가 큰 네트워크, 사업자



- 라우팅 알고리즘(Routing Algorithm)
  - 거리 벡터 알고리즘
    - 인접 라우터와 정보 공유
    - 목적지까지의 거리와 방향 결정
  - 링크 상태 알고리즘
    - 링크 상태 정보를 모든 라우터에 전달
    - 최단 경로 트리 구성



---

OSI(Open System Interconnection) 7계층

----

- 4계층, 전송 계층(Transport Layer)
  - 전송단위 : 세그먼트(Segment)



- 단위 테스트(Unit Test)
  - 요구사항에 대한 단위 모듈, 서브루틴 등을 테스트
  - 인터페이스, 자료구조, 실행 경로, 오류 처리 테스트



- 제품 소프트웨어 매뉴얼

  - 개발 단계부터 적용한 기준, 패키징 이후 설치, 주요내용 기록 문서
  - 사용자 중심의 기능 및 방법 설명서/안내서
  - 설치 매뉴얼, 사용자 매뉴얼

  

---

상향식 통합 테스트(Bottom-Up Integration Test)

---

1. 모듈/컴포넌트가 하위 모듈 기능을 수행하는 클러스터(Cluster)로 결합

2. 드라이버(Driver)라는 제어 프로그램 작성

3. 각 통합된 클러스터 단위 테스트

4. 클러스터가 위쪽으로 결합, 드라이버는 실제 모듈/컴포넌트로 대체



- 테스트 드라이버(Test Driver)
  - 상향식 통합 테스트
  - 데이터 입/출력을 확인하도록 하위 모듈 및 컴포넌트를 호출
  - 상위의 더미 모듈



- 스텁(Stub)
  - 하향식 통합 테스트
  - 모듈 및 하위 컴포넌트 대신하는 더미 모듈



- 빅뱅 테스트(Bigbang Test)
  - 모든 모듈 동시에 통합
  - 단시간에 통합 테스트 가능



---

통합 구현

---

- 송수신 방식
  - 직접 연계 방식
    - DB Link
    - JDBC
    - DB Connection Pool
    - API
    - Open API
  - 간접 연계 방식
    - EAI
    - ESB
    - Socket
- 중계 시스템
  - 송신 데이터의 오류 처리
  - 수신 데이터의 형변환 or 매핑
- 연계 데이터 표현 방식
  - 태그(Tag)
    - 유의미한 태그 그룹(Schema) 정의 후 상호 연계
  - 분리자(Seperator)
    - 콤마, 콜론, 세미콜론 등 분리자를 사용
    - CSV, TEXT
  - JSON
    - {키 : 밸류} 쌍의 구조
    - 객체, 변수 형식 표현
    - 텍스트 기반 데이터 교환 표준
- EAI(Enterprise Application Integration)
  - 기업에서 운영되는 서로 다른 플랫폼 및 애플리케이션 중계 시스템
  - 정보 전달, 연계, 통합 솔루션
  - 송수신 시스템에 설치되는 어댑터(Adapter)의 지원



---

EAI 구축 이전 연계 유형

---

- Point to Point 연계방식
  - 새로운 애플리케이션 추가 시 방대한 비용 및 시간 손실
  - App 수의 한계와 복잡성으로 유지/보수 어려움
- Hub & Spoke
- ESB(Enterprise Service Bus)
- 하이브리드(Hybrid) 방식

  - 그룹 내 : Hub & Spoke 방식

  - 그룹 간 : ESB(Message Bus) 방식
  - 환경에 맞는 구성 및 작업 가능





---

요구사항 개발 프로세스

---

1. 요구사항 도출(Elicitation)

2. 요구사항 분석(Analysis)
3. 요구사항 명세(Specification)
4. 요구사항 확인/검토(Validation)



---

요구사항 확인 기법

---

- 요구사항 검토
  - 검토자 그룹
  - 명세서 완성 시점에서 검토
- 프로토타이핑(Prototyping)
  - 요구사항 확인 수단 (요구사항이 불명확하거나 구현 가능성, SW 성능 등을 평가할 때)
  - 인터페이스의 동적인 행위가 문서/그래픽 모델보다 용이
  - 전체적인 주요 기능을 간략한 형태로 실제로 구현한 시제품 : 프로토타입
  - 사용자의 피드백을 통해 개선, 보완
- 모델 검증
  - 요구사항 분석 단계
  - 객체모델의 경우 정적 분석에 유용
- 인수 테스트(Acceptance Test)
  - 최종 제품을 기준으로 만족 여부
  - 사용자가 실제로 사용될 환경
  - 요구사항 충족 여부를 사용자의 입장에서 확인
  - 알파, 베타 테스트



- 알파 테스트
  - 상품 출시 전
  - 개발 인력이 성능 확인
- 베타 테스트
  - 선발된 잠재 고객 무료 사용
  - 오류 수정 & 보완



- 릴리즈 노트 작성 프로세스
  1. 모듈 식별 ★
  2. 릴리즈 정보 확인
  3. 릴리즈 노트 개요 작성
  4. 영향도 체크 ★
  5. 정식 릴리즈 노트 작성
  6. 추가 개선 항목 식별



---

UI (User Interface)

---

> 사용자와 시스템 사이 의사소통
>
> 물리적, 가상의 매개체

- UI 설계 기본 원칙
  - 이해성(Understandability)
    - 누구나 쉽게 이해 + 사용 가능
  - 유효성(Efficiency)
    - 정확하고 완벽하게 유효하게 사용자 목표 달성
  - 학습성(Learnability)
    - 초보/숙련자 모두 쉽게 배우고 사용
  - 유연성(Flexibility)
    - 사용자 인터랙션 포용
    - 실수 방지

- 화면 설계 방향
  - 사용자 중심
  - 단순한 설계
  - 현명한 색상 사용
  - 일관성 유지
  - 사용자 경험 지식화
  - 지속적인 테스트 및 반복
- 화면설계 수행 절차
  - UI 표준 수립 ★
  - UI 요구사항 분석
  - 프로토타입 작성
  - UI 작성 구조(흐름)
  - UI 구조 설계
  - UI 사용성 검토
- UI 스타일 가이드
  - 사용자 인터페이스(UI)를 만들 때 기준
  - 각종 규칙들의 집합
  - Introduction, Basic Rule, Layout, Elements, 정책, 기본환경 구성 ★
- UI 요구사항
  - 명확성(Unambiguous)
    - 항상 동일한 의미로 해석
  - 정확성(Correct)
    - 고객이 정말 원하는 것
  - 완전성(Complete)
    - 모든 기능/비기능 요구사항 기술
  - 일관성(Consistent)
    - 상충되는 요구사항 X
  - 실현가능성(Feasible)
    - 기술적/경제적으로 구현 가능
  - 추적성(Traceable)
    - 소스와 구현 결과 추적가능
  - 검증성(Verification)
    - 구체적이어야 함
- 그래픽 기반 사용자 인터페이스(GUI) 
  - 이미지 사용
  - 상호작용 인터페이스
- GUI 구성요소
  - 윈도우(Window)
    - 내용을 보여주는 일종의 상자
  - 아이콘(Icon)
    - 의미를 이해하기 쉽게 하는 그림 및 오브젝트
  - 메뉴(Menu)
    - 조직 순서 알람표
  - 포인터(Pointer)
    - 선택하여 실행하는 포인팅 장비



---

프로그래밍 언어

---

- 리스프(LISP)
  - 수학 표기법 목적
  - 함수형 언어
  - 함수 호출 시 함수 이름/연산자가 첫 번째로 위치
- HTML
- 알골(ALGOL)
  - 알고리즘 연구개발 목적
  - 절차형 언어로 최초로 재귀호출 가능
- 하스켈(Haskell)
  - 함수형  언어
  - 부작용 無
  - 코드 간결
  - 에러 발생 가능성 低
  - 재귀 함수, 대수적 자료형 지원
- 프롤로그(Prolog)
  - 논리식 기반
  - 인공지능/계산 언어학/자연언어 처리 분야
- 파이썬(Python)
- 펄(Perl)



---

성능 분석 도구

---

- 성능 테스트 도구
  - 애플리케이션에 부하, 스트레스 적용
  - 성능 측정 지표 점검
  - JMeter, LoadUI, OpenSTA
- 모니터링 도구
  - 애플리케이션 실행 시 시스템 자원 사용량 확인
  - Scouter, Zabbix



---

애플리케이션 성능 측정 지표

---

- 처리량(Throughput)
  - 주어진 시간 안에 처리할 수 있는 트랜잭션 수
  - 시간당 페이지 수
- 응답시간(Response Time)
  - 입력이 끝난 후 응답 출력 개시까지의 시간
  - 메뉴 클릭 시 메뉴가 나타나기까지의 시간
- 경과시간(Turn-around Time)
  - 요구 입력한 시점부터 결과의 출력이 완료할 때까지의 시간

- 자원(Resource) 사용률

  - 애플리케이션이 트랜잭션을 처리하는 동안
  - 사용하는 CPU, 메모리, 네트워크 사용량





---

현행 시스템 파악

---

- 1단계
  
  - 시스템 구성 현황 파악
  - 시스템 기능 파악
- 시스템 인터페이스 현황 파악
  
- 2단계

  - 아키텍처 파악
    - 계층별 기술 요소 표현
  - 소프트웨어 구성 파악
    - 설치된 SW 제품명, 용도, 라이선스 명시

- 3단계

  - 시스템 하드웨어 현황 파악
  - 네트워크 구성 파악

  

- 결함 관리 프로세스

  1. 에러 발견
  2. 에러 등록
  3. 에러 분석
  4. 결함 확정
  5. 결함 할당
  6. 결함 조치
  7. 결함조치 검토 및 승인



---

웹 서비스(Web Service)

---

- UDDI(Universal Description, Discovery, Integration)

  - 웹 서비스에 대한 정보인 WSDL를 등록, 검색하기 위한 저장소
  - 공개적 접근, 검색이 가능한 레지스트리 및 표준

- WSDL(Wev Service Description Language)
  - 웹 서비스명, 제공 위치, 메시지 포맷, 프로토콜 정보 등
  - 웹 서비스에 대한 모든 상세정보
  - XML 형식으로 기술한 언어 or 파일
- SOAP(Simple Object Access Protocol)
  - HTTP, HTTPS, SMTP 등 사용
  - XML 기반 메시지
  - 네트워크 상태에서 교환 프로토콜



---

유스케이스(Usecase) 다이어그램

---

- 유스케이스(Usecase)
  - 시스템이 제공하는 서비스
  - 액터가 하는 일련의 행위
  
- 액터(Actor)
  - 수행하는 역할
  - 시스템과 상호작용하는 사람/사물
  
- 시스템(System)
  
  - 전체 시스템 영역
  
- 구성요소간 관계(Relationship)
  - 연관(Association)
    - 유스케이스와 액터간의 관계 (실선)
  - 포함(Include)
    - `<<include>>`
  - 확장(Extend)
    - `<<extend>>`
  - 일반화(Generalization)
    - 기능/역할 상속받음
    - 빈 화살표
  
- 스테레오 타입(Stereo Type)
  - 관계
    - `<<include>>`
    - `<<extend>>`
  - 클래스 
    - `<<interface>>`
    - `<<entity>>`
    - `<<boundary>>`
    - `<<control>>`
  
- UI 유스케이스 기술서

  > 사용자의 관점에서 서비스/기능/외부요소 상세하게 기술한 산출물

  - 유스케이스 명, 액터명, 개요 및 설명, 사전 및 사후조건
  - 작업 흐름
  - 시나리오



- 고객 여정 지도(Customer Jorney)
  - 제품 및 서비스를 사용할 때 경험하는 요소들
  - 고객의 경험에 따라 나열한 도구



- 웹 호환성
  - HW 및 SW 환경이 다른 경우
  - 동등한 서비스 제공

- HTML 5

  > 하위 호환성, 간단한 문법

  - 비디오, 오디오 등 다양한 부가기능
  - 최신 멀티미디어 콘텐츠
  - 플러그인(Active X) 없이 브라우저에서 쉽게 볼 수 있음 ★



---

요구사항

---

- 기능적 요구사항

  > 시스템/서비스가 제공하는 기능

  - 기능성
  - 완전성
  - 일관성

- 비기능적 요구사항

  > 시스템이 수행하는 기능 이외의 사항, 시스템 구축에 대한 제약사항

  - 신뢰성
  - 사용성
  - 효율성
  - 유지보수성
  - 이식성



- UI 흐름 설계 수행 절차
  1. UI 설계 적정성 확인
  2. 화면에 표현될 기능/비기능 요구사항 검토 (+유스케이스를 통한 요구사항 확인)
  3. 유스케이스 설계
     - 액터(Actor)별 시나리오 구상
     - UI 요구사항으로 액터 세분화
     - UI 유스케이스 설계
  4. 기능 및 양식 확인
     - Input Box, Combo Box, Radio Box, Check Box 확인 및 규칙 정의



- 테스트 케이스(Test Case) 작성 순서
  1. 테스트 계획 검토 및 자료 확보
  2. 위험 평가 및 우선순위 결정
  3. 테스트 요구사항 정의
  4. 테스트 구조 설계 및 테스트 방법 결정
  5. 테스트 케이스 정의
  6. 테스트 케이스 타당성 확인 및 유지 보수



---

데이터 마이닝(Data Mining)

---

>  대규모로 저장된 데이터
>
> 체계적이고 자동적
>
> 통계적 규칙 및 패턴을 찾아내는 기술

- 군집 분석
  - 유사성 측정
  - 유사성 높은 대상 집단 분류 & 특성 도출
  - 데이터 간의 거리 기준



- 프로토콜(Proctocol)의 3요소
  - 구문(Syntax)
  - 의미(Semantic)
  - 타이밍(Timing)



- XML(eXtensible Markup Language)

  - W3C(World Wide Web Consortium)에서 개발
  - 웹 브라우저간 호환 문제 해결
  - SGML(Standard Generalized Markup Language)의 복잡함 해결

  - 다목적 마크업 언어



- JSON
  - 속성-값 쌍(Attribute-Value Pair)
  - 데이터 오브젝트를 전달
  - 개방형 표준 포맷 / 언어 독립형 데이터 포맷



---

암호화 해시 함수

---

- MD5
  - RFC 1321로 지정
  - 프로그램/파일이 그대로인지 무결성 검사
  - 128비트 암호화 해시 함수

- 솔트(Salt)
  - 일방향 해시 함수
  - 다이제스트를 생성할 때 추가
  - 바이트 단위의 임의의 문자열



- 헤더(Header)
  - 제품 패키지 릴리즈 노트 작성 항목
  - 문서/제품 이름, 버전,  릴리즈 날짜 등의 정보



- LoC (Line of Code)
  - 프로젝트 기간 = Man Month(월간 생산성) / 프로젝트 인력



- 안드로이드(Android)
  - Linux위에서 구동
  - 휴대용 장치를 위한 운영체제, 미들웨어, 인터페이스, 응용 프로그램 포함
  - 자바 및 코틀린 사용 운영체제



---

디자인 패턴(Design Pattern)

---

- 옵저버(Observer) 패턴
  - 객체의 상태가 변하면 모든 연결 객체에 알림, 업데이트
  - 느슨한 결합



- 클러스터 설계 시 고려사항
  - 검색 효율은 높여주나 CRUD 시 부하가 증가
  - 검토대상
    - UNION, DISTINCT, GROUP BY, ORDER BY가 빈번한 컬럼
    - 수정이 자주 발생하지 않는 컬럼
  - 단일 테이블 클러스터링
    - 처리 범위가 넓어 문제가 발생하는 경우
  - 다중 테이블 클러스터링
    - JOIN이 많아 문제가 발생되는 경우



- 디스크 구성 설계 방법
  - 업무량 집중 디스크를 분리하여 설계
  - 입출력(I/O) 경합을 최소화하여 데이터 접근 성능 향상
  - 파티션 수행 테이블은 별도로 분류
  - 디스크 구성에 따라 테이블 스페이스 개수와 사이즈 결정





---

데이터베이스(DataBase)

---

- 정규화(Normalization)

  - 데이터베이스의 무결성 보장/보존
  - 데이터 테이블의 중복성 제거

  - 무손실 분해 & 중복성 제거 & 분리의 원칙

- 정규형

  1. 제1정규형(1NF)

     - 모든 속성이 원자값(Atomicity)을 갖는 릴레이션

  2. 제2정규형(2NF)

     - 완전함수 종속성 O
     - 부분함수 종속성 제거

  3. 제3정규형(3NF)

     - 비이행함수 종속성 O

     - 이행함수 종속성 제거

  4. Boyce-Codd 정규형(BCNF)

     - X → Y에서 모든 결정자가 후보키(Candidate Key)

  5. 제4정규형(4NF)

     - 다가종속/다가결정 속성 제거

  6. 제5정규형(5NF)

     - 조인 종속성 O

- 반정규화(De-Normalization)
  - 정규화된 엔티티, 속성, 관계
  - 데이터베이스/시스템 성능 개선 & 개발 운영의 단순화
  - 병합, 중복, 분리 등 수행
  - 데이터 모델링 기법
- CRUD 매트릭스(Matrix)
  - 프로세스와 엔티티의 상관관계 기반
  - 엔티티 관계도 검증 도구
  - CRUD 여부 표기한 표

---

데이터베이스 파티셔닝

---

- 파티션(Partition)
  - 데이터 접근 범위 감소 & I/O 개선 = 성능 향상
  - 훼손 가능성 감소 & 가용성 향상
  - 독립적 백업, 복구 가능

- 종류
  - 레인지 파티셔닝(Range Partitioning)
  - 해시 파티셔닝(Hash Partitioning)
  - 리스트 파티셔닝(List Partitioning)
  - 컴포지트 파티셔닝(Composit Partitioning)



- 일반화 관계(엔티티 → 테이블 변환 시)
  - 슈퍼 타입 기준 변환
    - 슈퍼 엔티티에 통합(하나의 테이블)
      - 데이터 액세스 용이
      - 수행 속도 개선 & 조인 감소
      - 컬럼 및 블록수 증가
      - 인덱스 크기 증가
  - 서브 타입 기준 변환
    - 서브 타입에 복제(슈퍼 여러개가 각자 포함)
      - 단위 테이블 크기 감소
      - 서브 타입 속성들이 서로 관련 없을 때
      - Union 발생 가능 & SQL 복잡
  - 개별 타입 기준 변환
    - 각각 테이블로 변환(형태 그대로)
      - 서브 타입 처리가 독립적일 때
      - 컬럼 수가 지나치게 많은 경우 효과적
      - SQL 복잡 & CRUD 빈번



- SQL 성능 튜닝
  - 원할안 업무 처리
  - DB 트랜잭션의 성능 개선 활동



- PL / SQL

  - SERVEROUTPUT

    > PL / SQL 처리결과를 화면에 출력

  - SHOW ERRORS

    > 오류내용 확인



---

인덱스(Index)

---

> 검색 연산의 최적화 ★
>
> DB 내의 각 Row에 대한 정보를 구성한 데이터 구조
>
> 필요한 정보만 검색하여 신속한 조회

- 인덱스 설계 순서

  1. 인덱스 대상 선정
  2. 인덱스 최적화(Optimization)
  3. 인덱스 정의서 작성 ★last

- 인덱스 구조 설계
  - B-트리(Tree) 인덱스
    - 일반적 인덱스 방식
    - 루트 노드에서 하위 노드로 키 값의 크기를 비교해가며 검색
    - 키 값과 레코드를 가리키는 포인터들이 오름차순 저장
  - 비트맵(Bitmap) 인덱스
    - 분포도가 좋은 컬럼에 적합 (성능 향상)
    - 인덱스 컬럼을 0, 1로 변환 후 인덱스 키(Key)로 사용
    - 키 값을 포함하는 로우(Row)의 주소 제공 목적
  - 해시 기반 인덱스
  - 함수 기반 인덱스

- 인덱스 내림차순 스캔

  ```mysql
  /*+ Index_DESC (emp idx_empno)*/
  ```

- 비용기반(Cost-based) 접근 방법 선택

  > 전체적인 처리작업 필요 => Full-scan 피할 수 없음 => 단위 처리량(Throughpu을 최적화

  ```java
  /*+ ALL_ROWS */
  ```

- 인덱스 컬럼 선정 기준
  - 분포도(Selectivity)가 좋은 컬럼은 __단독__적으로 생성 (10~15%)
  - 자주 조합되어 사용되는 컬럼은 __결합 인덱스(Complex Index)__ 생성
    - 순서 중요
    - 분포도가 좋은 칼럼이 앞으로
    - 정렬 자주 발생 컬럼이 앞으로
  - 가능한 수정이 빈번하지 않은 컬럼을 선정

- 옵티마이저(Optimizer)

  > SQL문의 문법적 오류 확인
  >
  > 가장 빠른 데이터 액세스 경로 작성 및 채택

  - CBO(Cost Based Optimizer)
    - 통계 정보
    - 접근경로 고려
    - 최적화된 실행 수립
  - RBO(Rule Based Optimizer)
    - 미리 정해진 Rule
    - 질의 실행 계획 수립

  - 옵티마이저 HINT 문법
    - 옵티마이저가 항상 최적화된 실행 계획을 수집하는 것은 아님
    - 옵티마이저가 비정상적인 실행 계획을 수립 시
    - 액세스 경로 및 JOIN 순서를 제어

- 클러스터(Cluster) 설계
  - 컬럼 값의 순서대로 Row 저장 방법
  - 데이터 접근 효율 & 검색 효율 향상
  - CRUD 시 부하 증가

---

뷰(View)

---

- 뷰 설계 원칙
  - 테이블 구조의 단순화
  - 보안 유지 고려
  - 논리 데이터 독립성 유지 고려

- 뷰 대상 선정
  - 외부 시스템 & 인터페이스 관여
  - 여러 테이블 동시에 자주 조인
  - 인라인 뷰 방식으로 접근



- 물리 데이터 모델
  - 사용하고자 하는 DBMS의 특성을 고려
  - DB 저장 구조로 변환하는 모델링 기법

- 물리 모델링데이터 유형
  1. CHAR : 최대 200바이트의 고정길이 문자열 저장
  2. VARCHAR2 : 4000바이트의 가변길이 문자형
  3. NUMVER : 38 자리 숫자 저장
  4. DATE : 날짜 값을 저장 
  5. BLOB or CLOB : 바이너리 or 텍스트(문자열) 데이터 최대 4기가 저장



- ERD(Entity-Relationship Diagram)

  - 현실 세계에 존재하는 데이터와 그 관계
  - 이해할 수 있는 형태
  - 모델링하여 명확하게 보여줌

  

- DFD(Data Flow Diagram)
  - 프로세스를 따라 흐르면서 데이터 변환 모습 (=데이터 흐름에 중심)
  - 프로세스, 데이터 흐름, 데이터 저장소, 외부 엔티티로 구성
  - 시스템 모델링 도구
  - 기능이 복잡하고 중요할 경우 유용



- QoS (Quality of Service)

  - 데이터 종류에 따른 우선순위에 따라 데이터 전송
  - 특정 통신을 위한 네트워크 대역폭 예약

  - 일정한 속도로 통신



- VPN(Virtual Private Network)
  - 회사/단체가 바깥에 드러내지 않고 통신
  - 공중 네트워크를 통한 사설 통신망 효과
  - 터널링(Tunneling) 기법/프로토콜 사용
    - IPsec 프로토콜로 구현
    - HTTPS, 443 Port를 이용한 SSL로 구현

- SSL(Secure Socket Layer)
  - 웹 브라우저와 서버간 통신정보 암호화
  - 정보 보호 솔루션
- IPSec VPN
  - IP계층 안전한 전송/통신
  - 3계층 터널링 프로토콜
  - IP계층 내에서 직접 서비스 제공(패킷 암/복호화)
  - 호환성 고려 X

---

IPsec(IP SECurity) 세부 프로토콜

---

> 무결성과 인증을 보장하는 AH, 기밀성을 보장하는 ESP를 이용한 IP 보안 프로토콜

- IKE(Internet Key Exchange)
  - 보안 관련 설정들을 생성, 협상 및 관리
  - UDP 500번 포트를 사용
- ESP(Encapsulating Security Payload)
  - 메시지 인증 코드(MAC)와 암호화를 이용
  - 인증(무결성), 송신처 인증, 기밀성 제공
- AH(Authentication Header)
  - 기밀성(암호화)을 제외한 메시지 인증 코드(MAC) 이용
  - 인증(무결성), 송신처 인증 제공



- DHCP (Dynamic Host Configuration Protocol)

  - 동적으로 IP 주소 및 구성정보를 부여/관리
  - PC 수 or 변동사항이 많은 경우
  - 자동적 IP 설정 및 할당

  - 효율적 + 충돌 방지



- 쉘 (Shell)
  - 다양한 운영 체제 기능과 서비스 구현 인터페이스 제공
  - 사용자와 운영 체제 내부(Kernal) 사이의 인터페이스



- 문서 이력 정보
  - 제품 SW 사용자 매뉴얼 작성 항목
  - 버전, 작성자, 작성일, 검토자, 일시, 검수인 등 일자별로 기록



- 데이터 웨어하우스(Data Warehouse)
  - 업무 시스템에서 모아진 정보
  - 일관된 스키마로 저장한 저장소

- ETL (Extract Transform Load)
  - 수집 대상 데이터를 추출 및 가공(변환/정제)
  - 데이터 웨어하우스에 저장 기술



- 포렌식(Forensic)
  - 범죄 사실의 전자적 증거물
  - 일련의 수집, 분석, 보고서 작성 과정



---

법칙 & 원리

---

- 파레토(Pareto)의 법칙
  - 전체 결과의 80%가 전체 원인의 20%에서 일어나는 현상

- 브룩스(Brooks)의 법칙

  - SW 개발 지연 시
  - 새로운 개발 인력을 진행 중인 PJT에 투입

  - 적응 기간 & 부작용 => 일정이 더욱 지연

- 살충제 패러독스
  - 동일한 테스트케이스에 의한 반복적 테스트
  - 새로운 버그나 결함을 찾지 못한다는 테스트의 원리







---

SW 프레임워크(Framework)

---

> 컴포넌트(라이브러리) 재사용을 통한 개발 비용 절감
>
> 모듈화를 통한 유지 보수 용이성
>
> 품질 보장

- 개발 프레임워크 특징
  - 모듈화(Modularity)
    - 인터페이스에 의한 캡슐화 + 모듈화 강화
    - 설계/구현의 변경 영향 극소화
    - SW 품질 향상
  - 재사용성(Reusability)
    - 반복적으로 사용하는 컴포넌트를 정의
    - SW 품질 & 개발 생산성 향상
  - 확장성(Extensibility)
    - 다형성(Polymorphism)을 통해 애플리케이션이 프레임워크의 인터페이스를 넓게 사용 가능
  - 제어의 역흐름(Reverse flow of Control)
    - 프레임워크 코드가 전체 애플리케이션의 처리 흐름을 제어(?????????)

- 스프링 프레임워크(Spring Framework)

  - Java 플랫폼을 위한 오픈 소스 애플리케이션 서버 개발 프레임워크
  - 동적인 웹 사이트 개발 서비스 제공
  - 전자정부 표준 프레임워크 기반 기술
  - SW 표준화 목적
    - 품질 및 재사용성 향상
  



- 서버 프로그램 구현 절차
  1. DTO(Data Transfer Object) or VO(Value Object) 구현
     - 프로그램 계층 간 데이터의 교화능ㄹ 위해 사용
  2. SQL문 구현
     - DB에 저장된 데이터를 조작하는 질의문
     - Mybatis와 같은 프레임워크로 관리 (XML 파일)
     - 변경 영향도 감축 & 쿼리최적화/성능개선 & 유지보수
  3. DAO(Data Access Object) 구현
     - DB에 접근하여 CRUD 역할
     - DB Connection 관리부 vs 입출력 DTO/VO 지정부 코드 분리 => 효율적
     - MyBatis, JDB Connection Pool 사용
  4. Service 구현
     - 사용자 요청에 따른 비즈니스 로직 처리 객체
  5. Controller 구현
     - 처리 결과를 사용자에게 전달
     - Servlet이 담당
  6. 화면 구현



---

SW 개발 보안

---

> 개발 과정에서 실수, 논리적 오류 등으로 인한 보안 취약점 최소화
>
> 사이버 보안 위협에 대응하는 일련의 보안활동

- 방법
  - 표준코딩 정의서 or SW 개발보안가이드 준수
  - 단위 테스트
  - 코드 리뷰 or 소스 코드 진단 작업 수행

---

시큐어 코딩 가이드(Secure Coding Guide) 보안 약점

---

- 입력 데이터 검증 및 표현

  - 입력값에 대한 검증 누락, 부적절한 검증, 잘못된 형식 지정

  - 유효성 검증체계 수립

  - 실패 시 처리 설계 및 구현

  - XSS(크로스사이트 스크립트), SQL 인젝션 공격 유발

    - XSS(Cross Site Script)

      > 웹사이트 관리자가 아닌 이가 웹 페이지에 악성 스크립트를 삽입하는 취약점

  > 해커가 사용자의 정보(쿠키, 세션, 토큰 등)를 탈취하거나 비정상적 기능을 수행시킴

- SQL Injection

  - 응용프로그램의 보안 취약점을 이용해서 __악의적인 SQL 구문을 삽입/실행유도__
  
  - 정상적인 SQL 쿼리를 변조
  
  - 불법 로그인, DB 데이터 열람, 시스템 명령 실행 등
  
  - DB의 접근을 통해 정보를 탈취 or 조작하는 행위의 공격기법

- 보안취약점

  - 인증, 권한 관리, 암호화, 중요정보 처리 부적절하게 구현

- 시간 및 상태

- 에러처리

- 정수형 오버플로우

  - 의도하지 않게 아주 작은 수 or 음수
  - 결과값 범위 검사 모듈 사용

- 코드오류

  - 민감한 정보를 포함한 오류 메시지 생성
  - 최소한의 유용한 정보만 제공

- 캡슐화

  - 잘못된 세션에 의한 정보 노출
  - 제거되지 않은 디버그 코드
  - 시스템 정보 노출

- API 오용

  - 취약한 API 사용



- 배치(Batch) 프로그램
  - 대용량 데이터
  - 견고함
    - 비정상적인 실행 중단 X
  - 자동화
    - 사용자 개입 X
  - 신뢰성
    - 문제 추적 가능
  - 성능
    - 주어진 시간 내에 처리
    - 다른 애플리케이션 방해 X
- 스프링 배치(Spring Batch)
  - 애플리케이션(Application)
    - 비즈니스 로직 처리
  - 배치 코어(Batch Core)
    - 배치작업 실행, 제어, 모니터링
  - 배치 인프라(Batch Infrastructure)
    - 애플리케이션과 배치 코어에서 공통되게 사용하는 서비스 기능

- 배치 스케줄러(Scheduler)

  - 일정한 규칙 실행 지원
    - 주기적 동작
    - 특정한 이벤트 발생 시 반복 수행

  - cron(Unix / Linux)
    - 특정 시간마다 작업 실행
  - 작업 스케줄러(Window OS)
  - Quartz
    - 오픈소스 스케줄러
    - 스프링 배치와 통합하여 사용



---

데이터 통신 인터페이스

---

- 예외 처리 방식
  - 송신 측
    - AJAX 호출 후 반환 값 어떻게 처리할지를 호출하는 부분에서 사전 정의 (실패 시 예외 처리)
  - 수신 측
    - JSON 객체를 처리 시에 `try-catch` 구문 이용
    - 예외 처리 후 송신측에 전달



- Java 3대 용어
  - JVM (Java Virtual Machine)
    - 자바 바이트코드의 실행 주체
    - CPU/운영체제 종류와 무관한 동작 보장
    - 가상머신
  - JRE (Java Runtime Environment)
    - 자바 코드 실행 SW
  - JDK (Java Development Kit)
    - 자바 응용 SW 개발 키트



---

객체지향 프로그래밍 언어 특징

---

- 상속(Inheritence)
  - 상위 클래스의 모든 속성과 연산
  - 하위클래스가 물려받아 재사용
- 캡슐화
- 추상화
- 다형성
- 정보은닉



- 요구공학(Requirements engineering)
  - 요구사항에 대한 공학적인 관점
  - 체계적인 프로세스



---

UML(Unified Modeling Language)

----

> 객체 기술에 관한 국제 표준기구 OMG(Object Management Group)
>
> 시스템 분석/설계/구현 등 개발자와 사용자 간 의사소통
>
> 표준화 객체지향 모델링 언어

- 구성요소
  - 뷰(View)
  - 다이어그램(Diagram)
  - 모델 요소(Model Element)
  - 일반적 체계(General Mechanism)
- 요구사항
  - 유스 케이스
    - 사용자 입장에서 본 시스템의 행동
    - 시스템 기능적인 요구

- 정적 다이어그램
  - 클래스 다이어그램
    - 클래스의 정적 구조
    - 속성(Attribute)과 동작(Behavior)으로 구성
  - 객체 다이어그램
    - 클래스에 속한 객체들(인스턴스)
    - 특정 시점의 객체와 객체 사이의 관계로 표현
  - 컴포넌트 다이어그램
    - 코드의 물리적인 구조
  - 배포 다이어그램
    - 시스템 HW와 SW 간의 물리적 구조
- 동적 다이어그램
  - 시퀀스 다이어그램
    - 상호 작용하는 시스템이나 객체들이 주고받은 메시지 표현
    - 시간의 흐름
    - 시간 또는 순서
  - 협업 다이어그램
    - Object간의 연관성
  - 활동 다이어그램
    - Object의 행위(Activity)
    - 순차적 흐름
  - 상태 다이어그램
    - 객체의 모든 가능한 상태
    - 상태 간의 전이



- 내비게이션
  - UI에서 사용자가 원하는 정보 안내
  - 메뉴, 버튼, 링크로 구성



- Unix/Linux CLI (Command Line Interface) 명령어

  - cat

    - 파일 내용을 화면에 표시

    

---

관계 대수(Relational Algebra)

---

> 원하는 정보 & 유도 방법 기술
>
> 절차적 정형 언어
>
> 테이블에서 튜플을 검색하기 위한 연산자 모음

- 집합 연산자
  - 합집합
  - 교집합
  - 차집합
  - 카테시안 프로젝트
- 순수 관계 연산자
  - 셀렉트
  - 프로젝트
  - 조인
  - 디비전



- 사용자 인터페이스 설계 지침/고려사항
  - 사용자 중심
    - 이해하기 쉽고 편하게 사용 환경
    - 실사용자에 대한 이해
  - 가시성
    - 주요 기능 메인 화면에 노출
    - 쉬운 조작 가능
  - 접근성
    - 다양한 계층 수용



- 시맨틱 웹(Semantic Web)
  - 의미론적인 웹
  - 기계가 이해할 수 있는 형태로 제작된 웹



- 데이터 유출 방지(DLP, Data Loss Prevention)
  - 내부 정보 유출 방지 보안기술
  - 기업 내 정보 보호 및 외부 유출 방지



- COCOMO 모델
  - 프로그램 규모에 따라 비용 산정
  - 보헴(Bohem)이 제안
  - 개발 노력 승수를 결정
  - 단순형, 중간형, 임베디드형 (규모에 따라)
  - 상향식 비용산정 모델



- 인터프리터(Interpreter)
  - 프로그램 문장을 하나씩 번역하고 실행
  - 컴파일 과정이 없음
  - 개발 과정에서 유용
  - 실행 속도 느림 & 메모리 사용 비효율적



---

소프트웨어 아키텍처

---

- 마이크로 서비스 아키텍처
  - 독립된 서비스 단위의 여러 작은 애플리케이션으로 나눔
  - 변경과 조합이 유연
- 람다 아키텍처
  - Batch & Realtime 모두 지원
  - 빅데이터 실시간 처리 아키텍처
  - Batch, Serving, Speed 3개의 Layer
- 카파 아키텍처
  - 람다 아키텍처의 코드 공유 복잡성 해결
  - 배치 레이어 제거
  - 모든 계산 피드 레이어에서 처리



---

아키텍처 표준, IEEE 1471

---

- IEEE 1471 정의
  - 아키텍처 표준
  - 유연성(Flexible)과 확장성(Extensible)
  - SW 중심의 시스템 아키텍처 기술
  - 개념적 프레임워크 표준 모델

- IEEE 1471 특징 (독표범이가?)

  - 독립화
    - 모델링 언어와 방법론에 무관
    - 독립적 메타 모델 제공
  - 표준화
    - 관련 용어, 개념, 표현의 표준화
  - 범용성
    - 아키텍처 표현 요소, 관계 일반화
  - 의사소통
    - 의사소통 지원
    - 다양한 관점 표현
  - 가이드라인
    - 아키텍처 식별, 문서 작성 지원

- IEEE 1471 구성

  - 아키텍처 기술(AD, Architecture Description)

    > 아키텍처 기록 산출물

    1. 기술서 정보수집
    2. 관심 식별
    3. 관점 선택 (viewpoint)
    4. View 작성/조정

  - 이해관계자(Steakholders)

    > 의견 조정 및 요구사항 파악

    - 사용자 : 기본 기능 + 품질(신뢰성, 보안, 사용성)
    - 유지보수자
    - 개발자 : 적은 비용과 인력으로 개발
    - 마케팅 담당자

  - 관심사(Concerns)

    - 사용자 입장
    - 유지보수자 입장
    - 개발자 입장

  - 뷰(View) & 뷰포인트(VIewpoint)

    - 뷰 + 뷰를 구성하기 위한 규칙을 정의하는 패턴



---

소프트웨어 아키텍처

---

> 소프트웨어의 밑그림
>
> 복잡도를 높이는 요소들 체계적으로 다루는 청사진
>
> 모든 구조를 결정하는 초기 설계 성과물

- SW 아키텍처 4+1뷰(View)
  - 유스케이스(Usecase) 뷰
    - 요구사항 분석
    - 시스템 기능 명세화
  - 논리(Logical) 뷰
    - 요구사항들을 시스템 구조와 행동으로 명세화
    - 설계 모델의 추상화
    - 서브 시스템 클래스 식별
    - 기능적인 요구사항 지원
    - 클래스 다이어그램으로 표현
  - 프로세스(Process) 뷰
    - Tread와 Process에 의한 동작에 중점
    - 동시성, 분산처리, 시스템 통합, 오류 허용 등
  - 구현(Implementation) 뷰
    - UML 모델요소를 물리적인 SW 모듈로 표현
  - 배포(Deployment) 뷰
    - UML 모델요소를 배치할 HW 표현

- 아키텍처 드라이버(Artchitecture Driver)

  > 아키텍처 요구사항 항목 분석
  >
  > 항목 추출 및 정제
  >
  > 설계 원칙 및 근거로 표현

  - 기능요구사항(Functional Requirement)
    - 시스템이 수행해야 하는 기능
    - 기능 + 비기능
  - 품질속성(Quality Attributes)
    - 품질 및 성능, 안전성 등
  - 제약사항 (Constraints)
    - 사전에 고려해야 하는 요구사항

- 아키텍처 프레임워크
  
- 아키텍처 개발을 위한 틀
  
- 품질속성 시나리오
  - 자극의 원천(Source of Simulus)
  - 자극(Simulus)
  - 대상체(Artifact)
  - 환경(Environment)
  - 응답(Response)
  - 응답 측정(Rseponse Measure)



---

SW 아키텍처 스타일

---

> 아키텍처 설계에서 반복적으로 나타나는 문제 해결
>
> 시스템 품질 속성 달성 방법

- SW 아키텍처 특징
  - 아키텍처 구성 요소
  - 구성 요소 상호 관계 및 구성 방식
  - 요소의 의미와 한계
  - 상호작용 메커니즘

- 유형별 분류
  - 데이터 중심(Data-Centered)
    - 저장소에 대한 접근과 갱신 초점
    - Repository, Blackboard
  - 데이터 흐름(Data FLow)
    - 일련의 변형 동작
    - 재사용과 수정성 구현에 초점
    - Batch Sequence, Pipes and Filter
  - 가상 머신(Virtual Machine)
    - 이식성 구현에 초점
    - 인터프리터(Interpreter), 규칙 기반 시스템(Rule-based System)
  - 호출과 리턴(Call and Return)
    - 작은 단위 서브루틴
    - 수정성 구현에 초점
    - Main Program & Sub Routine, 원격 프로시저 호출(Remote Procedure Call)
  - 독립적 컴포넌트
    - 상호간 메시지 통신

- 종류

  - 저장소 구조(Repository Architecture)

    > 단일 중앙 저장소 자료 접근 및 변경

    - 컴포넌트 추가 & 삭제 편리
    - 데이터 관리 편리
    - 저장소 오류가 전체 영향

  - MVC구조(Model-VIew-Controller)

    > 데이터 구조가 변해도 다른 컴포넌트에 영향 적음

    - 하나의 데이터로 여러 표현(다형성)
    - 시스템 복잡

  - 클라이언트-서버 구조(Client-Server)

    > 클라이언트 : 입력받아 범위 체크 및 DB 트랜잭션 구동
    >
    > 서버 : 트랜잭션 수행 및 데이터 일관성 보장

    - 데이터 분배 쉬움
    - 클라이언트 편리
    - 서버 의존성 강함
    - 네트워크 영향
    - 서버 관리 어려움

  - Data Flow (Pipe and Filters)

    > 서브시스템 입력 결과 다른 시스템에 전송 반복

    - 이해가 쉽고 필터 단위 재사용
    - 출력이 입력으로 들어가므로 필터간 데이터 포맷 일치 필요

  - 계층구조(Layered)

    > 각 서브시스템이 하나의 계층

    - 유지보수 용이
    - 각 층 변경 가능
    - Layer 분리 어려움 및 성능 저하



---

디자인 패턴(Design Pattern)

---

> SW 설계에서 공통된 문제들에 대한 표준적인/정형화된 해법

- 디자인 패턴의 4요소

  - 패턴 이름(Pattern Name)
  - 문제(Problem)
  - 해법(Solution)
  - 결과(Consequence)

- 생성 패턴(Creational Pattern)

  > 객체의 생성 방식 결정
  >
  > 클래스의 정의
  >
  > 객체 생성 방식의 구조화, 캡슐화 지향

  - 클래스
    - 팩토리 메소드(Factory Method) : 인스턴스화 될 객체의 서브클래스
  - 객체
    - 추상 팩토리(Abstract Factory) : 제품 객체 군
    - 빌더(Builder) : 복합 객체 생성
    - 프로토 타입(Prototype) : 인스턴스화 될 객체 클래스
    - 싱글톤(Singleton) : 인스턴스가 1개

- 구조 패턴(Structural Pattern)

  > 객체를 조직화하는 방법
  >
  > 객체 구성에 유동성, 확장성 추가

  - 클래스
    - 어댑터(Adaptor) : 객체 인터페이스 (=Wrapper 패턴)
  - 객체
    - 브릿지(Bridge) : 개체 구현
    - 컴포지트(Composite) : 객체의 합성과 구조 
    - 데코레이터(Decorator) : 서브클래싱 없이 객체의 책임성
    - 퍼싸드(Facade) : 서브클래스에 대한 인터페이스
    - 플라이웨이트(Flyweight) : 객체 저장 비용
    - 프록시(Proxy) : 객체 접근방법

- 행위 패턴(Behavioral Pattern)

  > 행위를 조직화 관리, 연합
  >
  > 연동에 대한 유형 제시

  - 클래스

    - 인터프리터(Interpreter) : 문법과 해석 방법
    - 템플릿 메소드(Template Method) : 알고리즘 단계

  - 객체

    - 책임 연쇄(Chain of Responsibility) : 요청처리 객체
    - 커맨드(Command) : 요청처리 시점와 방법, 로그
    - 반복자(Iterator) : 집합객체 요소 접근/순회방법
    - 중재자(Mediator) : 객체 상호작용
    - 메멘토(Memento) : 객체 정보 외부저장
    - 옵저버(Observer) : 종속 객체 상태 변경
    - 상태(State) : 객체상태
    - 전략(Strategy) : 알고리즘
    - 방문자(Visitor) : 클래스 변경 없이 객체에 적용하는 오퍼레이션

    

- 유틸리티 트리(Utility Tree)

  > 시스템이 제공해야 하는 모든 품질 요구사항
  >
  > 우선순위 결정 도구ㅈ

  1. 유틸리티
  2. 품질 속성
  3. 세분화한 품질 속성
  4. 시나리오



- 요구사항 추출 기법
  - 인터뷰
  - 설문
  - 워크샵
  - 브레인 스토밍
  - 스토리 보드
  - 프로토 타이핑
  - 롤플레잉



- 좋은 요구사항의 특징
  - 정확성(Correct)
    - 상충 없는 정확한 요구 사항
  - 명확성(Unembiguous)
    - 각 명세 내용은 하나의 의미
  - 완전성(Complete)
    - 기능, 속성, 인터페이스, 제약 모두 포함
  - 검증 가능성(Verifiable)
    - 충족 여부 및 달성 정도 확인
  - 우선 순위 포함
    - 중요도 및 안정성(불변성) 기준
  - 일관성(Consistent)
    - 명세 내용 간 모순 X
  - 수정 용이성(Modifiable)
    - 쉽게 수정 가능
  - 추적 가능성(Traceable)
    - 추적 및 상호 참조 가능
  - 개발 후 이용성(Usability)
    - 운영 및 유지 보수
  - 이해 용이성(Understandable)
    - 사용자와 개발자의 이해



- 요구사항 검증(Validation)
  - 인스펙션
  - 프로토타입
  - 유즈케이스 다이어그램



- 애자일 방법에서의 요구사항 도출(Elicitation)
  - 스크럼(Scrum)
    - 제품 백로그(Product Backlog)
    - 스프린트 기간 중 개발 항목 선정
  - XP(eXtrem Programming)
    - 유저 스토리(User Story)







<끝>

